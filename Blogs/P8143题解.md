  
  
先说明一下已有10篇题解为什么还要交：现有的题解除了一篇都是官方思路，而个人认为官方思路并不是最好想到的，剩下的一篇递推时的说明不够清晰。我赛时为这道题耗了1h才想到现在的递推思路，自认为是最好想到的。  
  
题意：给定 $n$，求 $n$ 个点间连 $n$ 条边，每个点的度数为 $2$，且图中恰含偶数个环的方案数。  
  
如果把边看成有向边，$p_1-p_n$ 是一个排列，说明每个点的出度和入度均为 $1$。所以生成的图一定由若干个环组成。  
  
![](https://cdn.luogu.com.cn/upload/image_hosting/218cg5hz.png)  
  
考虑递推。设 $f_n$ 为 $n$ 个点时的答案，因为最后一定是若干个环，所以生成奇数个环的方案数就是 $n!-f_n$。  
  
看 $p_n$。若 $p_n=n$，则说明第 $n$ 个点自身处在一个自环中。所以一个这样的情况刚好对应一个 $(n-1)!-f_{n-1}$  
  
若 $p_n \neq n$，说明第 $n$ 个点与其他点组成一个环。将第 $n$ 个点拿出，剩下的 $n-1$ 个点也满足题目描述。相当于原有一个 $n-1$ 个点的情况，在其中的一个点后面插入了 $n$（类比链表插入），于是一个这样的情况对应 $n-1$ 个 $f_{n-1}$。  
  
转移方程：  
  
  
$$  
  f_n=(n-1)! - f_{n-1} + (n-1) \cdot f_{n-1}  
$$  
    
  
边界：$f_1=1$  
  
赛时没推到 $f_n=\dfrac{n!}{2}$，归纳应该易证。  
```cpp  
#include <cstdio>  
#define p 998244353  
using namespace std;  
int n, s = 1, a; //a 是那个 f 数组，被优化到一个变量了，s 是阶乘  
int main(){  
    scanf("%d", &n);  
    for(int i = 1; i < n; i++){  
        a = (1ll * (i - 1) * a + 1ll * s * i % p) % p; //这里是从 f[i] 转移至 f[i+1]  
        s = 1ll * s * i % p;  
    }  
    printf("%d\n", a);  
}   
```  
  
upd 2\.27 改了文中多处式子，重新审核  
<br>  
  

-----
分类：题解