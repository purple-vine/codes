不是特别难的思维题。

打完 E 还剩 1h，如果专心想说不定能想出来，然而看到通过人数仅 172 就放弃了，这是以后要杜绝的。

-------

题意：给定一个排列 $\{a_n\}$，有两种操作：

- 将最后数提到最前（Rotate）

- 删除一个数（Erase）

求操作 $k$ 次后最小字典序。

-----------

最小字典序看着是贪心。如果只有旋转，选最后 $k$ 个数中最小数与 $a_1$ 作比较。如果只有删除，迭代：在前 $k+1$ 个数中选取最小数 $a_i$，删去 $a_1-a_{i-1}$，然后把 $k$ 减去 $i-1$，对第二个数做一样的操作。如果到最后操作有剩余，就从后往前删。用线段树能做到 $O(n \log n)$，用单调栈能做到 $O(n)$。

这给我们的启示是第一个数的选择其实不多。现在考虑至少旋转一次的情况。

为了更好讨论，我们发现：旋转后删除与旋转前删除效果一致，所以强制先旋转在删除，且旋转后删除不占用操作次数。同时，我们应该让旋转过去的最后一个数不被删除，为防止一个状态被多次讨论。

那么就明晰了：只用讨论旋转过去后第一个数为从后往前 $k$ 数中最小数的情况。此时再做删除操作，复杂度同最前分析。

于是我们就得到了解法。其中关键的一步是统一了旋转与删除，即“先旋转后删除”。之后发现旋转过去后的数一定只是顺水推舟。先分别讨论了只有一种操作的情况也是一个重要的铺垫。

代码留坑待补。