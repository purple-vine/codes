  
  
纪念一下第一道独立做出的思维紫题，来写个题解。  
  
%lation，第一个做出这道题，并提示我们“要观察第三个样例”。  
> 第二题一点都不难，我看到样例三就当场想到正解了。  
> ——[$\color{black}{l}\color{red}{ation}$](https://www.luogu.com.cn/user/382274)  
  
  
----  
  
  
看到括号，我先想的是 dp。然而数据范围并不允许。观察数据范围，我们需要的是 $O(n \log n)$ 或 $O(n)$ 的算法。这启示我们往二分或贪心想。  
  
先列几个括号的性质：左括号一定加在负号后面（放在加号后面等于没加）、右括号一定在负号前面。有了这几条，再找找最大值有什么性质。  
  
听磊神的，来研究一下第三个样例。  
  
  
$$  
  1-(20-(13+14)-5)=13  
$$  
    
  
看不出什么，拆开看看。  
  
  
$$  
  1-20+13+14+5=13  
$$  
    
  
后面的符号都变成了加号。  
  
一个括号内一定是诸如 `-(a -b +c +d -e +f)` 的样子，现在我们只要让括号中的负数最多。这比较容易做到，以负数为分界线，把一个负数与它后面的正数放在一起，即可让那些正数也变成负数。  
  
`-(a -b +c +d -e +f) -> -(a - (b+c+d) - (e+f))`  
  
即可最大化括号中负数的个数。从括号中的第一个负号开始，后面的所有数字均可转为负号，即对最后的和有正贡献。只需枚举第一个括号的位置，就一定不会错过最优解。  
  
注意事项：  
- 一定要与没有加括号的情况取最大值（会挂在 `alladd` 上）  
- 前缀和弄清楚每个到底是什么，绝对值和还是带符号和  
  
  
code:  
```cpp  
#include <cstdio>  
#include <cmath>  
#include <algorithm>  
#define LL long long  
using namespace std;  
const int M = 100005;  
int a[M], p[M], n, op[M], cnt; LL maxx, s1[M], s2[M]; char c;  
//s1: 带符号前缀和 s2: 绝对值前缀和  
signed main(){  
    scanf("%d", &n);  
    for(int i = 1; i <= n; i++){  
        if(i != 1) scanf("  %c", &c);  
        else c  = '+';  
        op[i] = c == '+' ? 1 : -1;  
        scanf("%d", &a[i]); if(op[i] == -1) p[++cnt] = i;  
        s1[i] = s1[i-1] + 1ll * a[i] * op[i]; s2[i] = s2[i-1] + 1ll * abs(a[i]);  
    }  
    p[cnt+1] = n+1;  
    for(int i = 1; i <= cnt; i++){  
        int pl = p[i], pl2 = p[i+1];   
        LL ans = s1[pl-1] - (s2[pl2-1] - s2[pl-1]) + s2[n] - s2[pl2-1];  
        //s1[pl-1] 是枚举到的括号的前面部分，s2[pl2-1] - s2[pl-1] 是枚举到的括号与括号后第一个减号中间的部分的贡献，s2[n] - s2[pl2-1] 是最后一段的贡献  
        maxx = max(maxx, ans);  
    }  
    printf("%lld\n", max(maxx, s1[n]));   
}  
```  
<br>  
  

-----
分类：题解