  
  
注意到最后还原出的结果唯一，也就是对于编号为 $i$ 的点，仅有位置 $i$ 是它该去的。定义数组 $a$，表示**第 $i$ 个位置上的点的编号**，首先是要把 $a$ 求出来。  
  
注意到第 $i$ 条链连接的的两个点的编号一定是 $i$ 与 $i+1$，因此，这些链首尾相连，第 $i$ 号链与第 $i+1$ 号链的两个端点一定有一个是相同的，也就是所在的位置相同。考虑使用一个 $vis$ 数组，记录每个点已经出现的次数。假设处理到第 $i$ 条链的在位置 $u_i$ 的端点，如果这个点已经出现过一次了，就意味着这个处在 $u_i$ 位置的端点就是 $i$ 号端点，即 $a_{u_i}=i$。最后，第 $1$ 条链和第 $n-1$ 条链各有一个端点所在的位置只出现一次，也就是编号为 $1$ 和为 $n$ 的点所在位置只出现一次，这个可以在最后求出。  
  
这部分代码：  
```cpp  
int vis[M];  
for(int i = 1; i < n; i++){  
    scanf("%d %d", &u[i], &v[i]);  
    if(vis[u[i]]) a[u[i]] = i;  
    else if(vis[v[i]]) a[v[i]] = i;  
    ++vis[u[i]]; ++vis[v[i]];  
}  
if(vis[u[1]] == 1) a[u[1]] = 1;  
else a[v[1]] = 1;  
if(vis[u[n-1]] == 1) a[u[n-1]] = n;  
else a[v[n-1]] = n;  
```  
  
现在，我们已经有了一个数组 $a$，也可以顺便改写一下“操作”的含义了。  
  
一次操作现在可以定义为：在 $a$ 选定一个元素，左右拖动这个元素，每次交换这个元素和与它相邻的元素称为一次移动，求必须操作的点的最少值。  
  
明显每次移动，或交换可以减少一对逆序对。所以最小化后的操作次数就是逆序对数。接着想法最大化没有经过操作的那些数，也就是不动的那些数。  
  
找到原序列的最长上升子序列，如果最后不动数多于最长上升子序列序列的长度，因为这些数都没动，它们一定递增，与这个数列的长度大于最长上升子序列矛盾。所以猜测答案为最长上升子序列的长度。  
  
考虑一个个归位这些数字。设 $1-i$ 已经归位，则 $i+1$ 一定不在它该在的位置的左边，所以 $i+1$ 往左时一定不会与大于它的数字交换。所以能保证操作数最小。  
  
被固定住的数一定上升，所以固定无影响。  
  
所以，答案就是：$n-$ 最长上升子序列的长度。  
  
LIS 是可以 $O(n \log n)$ 求的。这里如果不懂请自行 bdfs，不再赘述。  
```cpp  
#include <bits/stdc++.h>  
using namespace std;  
const int M = 100005;  
const int inf = 0x3f3f3f3f;  
int n, a[M], dp[M];  
int u[M], v[M], deg[M], pl[M], vis[M];  
signed main(){  
    scanf("%d", &n);  
    for(int i = 1; i < n; i++){  
        scanf("%d %d", &u[i], &v[i]);  
        if(vis[u[i]]) a[u[i]] = i;  
        else if(vis[v[i]]) a[v[i]] = i;  
        ++vis[u[i]]; ++vis[v[i]];  
    }  
    if(vis[u[1]] == 1) a[u[1]] = 1;  
    else a[v[1]] = 1;  
    if(vis[u[n-1]] == 1) a[u[n-1]] = n;  
    else a[v[n-1]] = n;  
    memset(dp, inf, sizeof dp);  
    dp[0] = 0;  
    for (int i = 1; i <= n; i++)  
        *lower_bound(dp + 1, dp + n + 1, a[i]) = a[i];  
    printf("%d\n", n - (lower_bound(dp + 1, dp + n + 1, inf) - (dp + 1)));  
    return 0;  
}  
```  
<br>  
  

-----
分类：题解