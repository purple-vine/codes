老师真的很喜欢 COCI……

然而下午成了骗分大讲堂。

## T1 P4810

### 上午

整场唯一可做的题……

看着这些栈的继承关系就是一棵树，于是考虑把树建出来，把加入的数放在边上。然后发现 LCA 的深度似乎就是操作三要求的东西。想想证明就是边权互不相同。

至于删除操作，看着就是与父亲合并。这里开一个并查集维护就行了。

画了画图很对，于是开始写。只写了 40min 左右就写完了，一交就过了，感动。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int M = 300005;
int f[M][20], fa[M], n, val[M], v, d[M]; char op;
int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}
void merge(int x, int y){
    if((x = find(x)) != (y = find(y))) fa[y] = x;
}
void op1(int pl, int v){
    pl = find(pl);
    f[v][0] = pl; val[v] = v; d[v] = d[pl] + 1;
    for(int i = 1; i <= 19; i++) f[v][i] = f[f[v][i-1]][i-1];
}
void op2(int pl, int v){
    pl = find(pl);
    printf("%d\n", val[pl]);
    merge(v, f[pl][0]);
}
int lca(int u, int v){
	if(d[u] < d[v]) swap(u, v);
	for(int i = 19; i >= 0; i--) if(d[f[u][i]] >= d[v]) u = f[u][i];
	if(u == v) return u;
	for(int i = 19; i >= 0; i--) if(f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
	return u == v ? u : f[u][0];
}
void op3(int v, int w, int num){
    merge(num, v); v = find(v); w = find(w);
    printf("%d\n", d[lca(v, w)]);
}
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) fa[i] = i;
    for(int i = 1; i <= n; i++){
        // printf("i=%d\n", i);
        scanf(" %c %d", &op, &v);
        if(op == 'a'){
            op1(v, i);
        } else if(op == 'b') {
            op2(v, i);
        } else {
            int w; scanf("%d", &w);
            op3(v, w, i);
        }
        for(int j = 1; j <= n; j++) printf("%d-%d-%d ", j, f[find(j)][0], val[find(j)]); printf("\n");
    }
}
```

### 下午

看来大家的想法是一致的，全员通过 P4810.

然而除了 T1T2 居然没有一个 AC 了……

## T2 P7229

没写。

大意就是模拟，但是我这种写了也调不出来的人直接往后开了。

## T3 P7749

### 上午

很容易想到同一行的书要操作的最小次数就是 n-LIS。然而有多行，还要考虑操作的先后顺序，这很麻烦，似乎要建图跑网络瘤什么的。

看着很多人都卡在 $40$ 和 $80$ 就跳了。觉得他们是卡在边界的小问题。

### 下午

学长讲 ~~题~~ 如何骗分时说 $40$ 是 $-1$，再 $40$ 是 $0$，震惊。

确实是要建图。

首先能发现一个书架只要有空位就一定不会浪费操作次数。

如果第 $i$ 行有数要往第 $j$ 行去，就从 $i$ 向 $j$ 连有向边。

考虑每一个将有向边看成无向边后形成的连通块。如果全是满的，需要将一本书放到其它书架，会多余一次操作。否则，我们一定能用适当的操作顺序让一次操作都不被浪费。这样一个个连通块判过去，即可。

总结：前面的好想，后面建图那一块容易想到却难想清楚。

## T4 P7230

### 上午

这个 $k$ 真的小，感觉预处理很方便，然而带修不方便。看数据范围和要求的东西明显莫队也不合适。

想了很久只能想到二分长度再判一个端点的范围。但看难写遂弃之。

### 下午

> 112 真的很简单（指一个配合尺取的做法）—— 某学长

然而正解是线段树。

我们需要合并区间，所以要记区间前后缀某些数的出现。

考虑 `4 2 3 2 4 1` 这样的情况。在每个节点开两个数组 $status$ 和 $length$。

$status$ 存前缀二进制压缩后出现的不同数，$length$ 存对应 $status$ 对应回原数组时的区间长度。遇到前面出现过的数则不记录进两个数组。这样的状态只有 $k$ 个。

左右合并时用双指针，需要特判一个区间没出现够 $k$ 数的情况。这样的合并的复杂度仅有 $O(k)$。对于中间的更新答案同理。

对于修改操作，直接去修改存的数组。只会修改 $O(\log n)$ 个节点，重新合并 $O(\log n)$ 次，也就是一次 $O(k \log n)$。

查询同理，也是 $O(k \log n)$。

总复杂度 $O(mk \log n)$。

总结：还是对线段树的理解过于浅薄了。这种单点修改在线段树上确实好做。看到 $k$ 很小，可以考虑反而将 $k$ 当作下标（那两个数组的本质），反而将原数组中的对应下标作为值，从而省空间&好处理。

## T5 P7231

### 上午

真的不好做。像贪心，但一味贪心很容易 Hack。

想了想怎么枚举几块骨牌能覆盖的图案，觉得不好做，就放弃了。

### 下午

> 90 分真的很好拿。直接暴力当前放哪最优就行了。 ——ZXZ


## T6 P8037

### 上午

开始看错题了，以为要一直上升 / 下降。码了 40min 过了样例一交抱零。把数据下下来才发现自己把题看错的严重。

值得一提的是我的这道题的错解写的正是 T5 正解的那种前缀后缀线段树。如果把这个思路放到 T5 是不是就能成了呢？

后面继续想。觉得不带修是个好条件，不妨预处理每个数对应的合法右端点范围。但又想想不好求答案，还要取一个 `min`。然后就差不多吃饭了。

### 下午

没人有分，甚至连骗分都没人讲

就先这样吧。